//============================================================================
//
// MM     MM  6666  555555  0000   2222
// MMMM MMMM 66  66 55     00  00 22  22
// MM MMM MM 66     55     00  00     22
// MM  M  MM 66666  55555  00  00  22222  --  "A 6502 Microprocessor Emulator"
// MM     MM 66  66     55 00  00 22
// MM     MM 66  66 55  55 00  00 22
// MM     MM  6666   5555   0000  222222
//
// Copyright (c) 1995-1998 by Bradford W. Mott
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: M6502Low.ins,v 1.1 2004/06/28 01:24:09 stephena Exp $
//============================================================================

/** 
  Code and cases to emulate each of the 6502 instruction 

  @author  Bradford W. Mott
  @version $Id: M6502Low.ins,v 1.1 2004/06/28 01:24:09 stephena Exp $
*/

#ifndef NOTSAMEPAGE
  #define NOTSAMEPAGE(_addr1, _addr2) (((_addr1) ^ (_addr2)) & 0xff00)
#endif

{
      __label__ 
    l_0x00, l_0x01, l_0x02, l_0x03, l_0x04, l_0x05, l_0x06, l_0x07, l_0x08,
    l_0x09, l_0x0a, l_0x0b, l_0x0c, l_0x0d, l_0x0e, l_0x0f, l_0x10, l_0x11,
    l_0x12, l_0x13, l_0x14, l_0x15, l_0x16, l_0x17, l_0x18, l_0x19, l_0x1a,
    l_0x1b, l_0x1c, l_0x1d, l_0x1e, l_0x1f, l_0x20, l_0x21, l_0x22, l_0x23,
    l_0x24, l_0x25, l_0x26, l_0x27, l_0x28, l_0x29, l_0x2a, l_0x2b, l_0x2c,
    l_0x2d, l_0x2e, l_0x2f, l_0x30, l_0x31, l_0x32, l_0x33, l_0x34, l_0x35,
    l_0x36, l_0x37, l_0x38, l_0x39, l_0x3a, l_0x3b, l_0x3c, l_0x3d, l_0x3e,
    l_0x3f, l_0x40, l_0x41, l_0x42, l_0x43, l_0x44, l_0x45, l_0x46, l_0x47,
    l_0x48, l_0x49, l_0x4a, l_0x4b, l_0x4c, l_0x4d, l_0x4e, l_0x4f, l_0x50,
    l_0x51, l_0x52, l_0x53, l_0x54, l_0x55, l_0x56, l_0x57, l_0x58, l_0x59,
    l_0x5a, l_0x5b, l_0x5c, l_0x5d, l_0x5e, l_0x5f, l_0x60, l_0x61, l_0x62,
    l_0x63, l_0x64, l_0x65, l_0x66, l_0x67, l_0x68, l_0x69, l_0x6a, l_0x6b,
    l_0x6c, l_0x6d, l_0x6e, l_0x6f, l_0x70, l_0x71, l_0x72, l_0x73, l_0x74,
    l_0x75, l_0x76, l_0x77, l_0x78, l_0x79, l_0x7a, l_0x7b, l_0x7c, l_0x7d,
    l_0x7e, l_0x7f, l_0x80, l_0x81, l_0x82, l_0x83, l_0x84, l_0x85, l_0x86,
    l_0x87, l_0x88, l_0x89, l_0x8a, l_0x8b, l_0x8c, l_0x8d, l_0x8e, l_0x8f,
    l_0x90, l_0x91, l_0x92, l_0x93, l_0x94, l_0x95, l_0x96, l_0x97, l_0x98,
    l_0x99, l_0x9a, l_0x9b, l_0x9c, l_0x9d, l_0x9e, l_0x9f, l_0xa0, l_0xa1,
    l_0xa2, l_0xa3, l_0xa4, l_0xa5, l_0xa6, l_0xa7, l_0xa8, l_0xa9, l_0xaa,
    l_0xab, l_0xac, l_0xad, l_0xae, l_0xaf, l_0xb0, l_0xb1, l_0xb2, l_0xb3,
    l_0xb4, l_0xb5, l_0xb6, l_0xb7, l_0xb8, l_0xb9, l_0xba, l_0xbb, l_0xbc,
    l_0xbd, l_0xbe, l_0xbf, l_0xc0, l_0xc1, l_0xc2, l_0xc3, l_0xc4, l_0xc5,
    l_0xc6, l_0xc7, l_0xc8, l_0xc9, l_0xca, l_0xcb, l_0xcc, l_0xcd, l_0xce,
    l_0xcf, l_0xd0, l_0xd1, l_0xd2, l_0xd3, l_0xd4, l_0xd5, l_0xd6, l_0xd7,
    l_0xd8, l_0xd9, l_0xda, l_0xdb, l_0xdc, l_0xdd, l_0xde, l_0xdf, l_0xe0,
    l_0xe1, l_0xe2, l_0xe3, l_0xe4, l_0xe5, l_0xe6, l_0xe7, l_0xe8, l_0xe9,
    l_0xea, l_0xeb, l_0xec, l_0xed, l_0xee, l_0xef, l_0xf0, l_0xf1, l_0xf2,
    l_0xf3, l_0xf4, l_0xf5, l_0xf6, l_0xf7, l_0xf8, l_0xf9, l_0xfa, l_0xfb,
    l_0xfc, l_0xfd, l_0xfe, l_0xff;

    static const void* const a_jump_table[256] = 
    {
        &&l_0x00, &&l_0x01, &&l_0x02, &&l_0x03, &&l_0x04, &&l_0x05, &&l_0x06, &&l_0x07, &&l_0x08,
        &&l_0x09, &&l_0x0a, &&l_0x0b, &&l_0x0c, &&l_0x0d, &&l_0x0e, &&l_0x0f, &&l_0x10, &&l_0x11,
        &&l_0x12, &&l_0x13, &&l_0x14, &&l_0x15, &&l_0x16, &&l_0x17, &&l_0x18, &&l_0x19, &&l_0x1a,
        &&l_0x1b, &&l_0x1c, &&l_0x1d, &&l_0x1e, &&l_0x1f, &&l_0x20, &&l_0x21, &&l_0x22, &&l_0x23,
        &&l_0x24, &&l_0x25, &&l_0x26, &&l_0x27, &&l_0x28, &&l_0x29, &&l_0x2a, &&l_0x2b, &&l_0x2c,
        &&l_0x2d, &&l_0x2e, &&l_0x2f, &&l_0x30, &&l_0x31, &&l_0x32, &&l_0x33, &&l_0x34, &&l_0x35,
        &&l_0x36, &&l_0x37, &&l_0x38, &&l_0x39, &&l_0x3a, &&l_0x3b, &&l_0x3c, &&l_0x3d, &&l_0x3e,
        &&l_0x3f, &&l_0x40, &&l_0x41, &&l_0x42, &&l_0x43, &&l_0x44, &&l_0x45, &&l_0x46, &&l_0x47,
        &&l_0x48, &&l_0x49, &&l_0x4a, &&l_0x4b, &&l_0x4c, &&l_0x4d, &&l_0x4e, &&l_0x4f, &&l_0x50,
        &&l_0x51, &&l_0x52, &&l_0x53, &&l_0x54, &&l_0x55, &&l_0x56, &&l_0x57, &&l_0x58, &&l_0x59,
        &&l_0x5a, &&l_0x5b, &&l_0x5c, &&l_0x5d, &&l_0x5e, &&l_0x5f, &&l_0x60, &&l_0x61, &&l_0x62,
        &&l_0x63, &&l_0x64, &&l_0x65, &&l_0x66, &&l_0x67, &&l_0x68, &&l_0x69, &&l_0x6a, &&l_0x6b,
        &&l_0x6c, &&l_0x6d, &&l_0x6e, &&l_0x6f, &&l_0x70, &&l_0x71, &&l_0x72, &&l_0x73, &&l_0x74,
        &&l_0x75, &&l_0x76, &&l_0x77, &&l_0x78, &&l_0x79, &&l_0x7a, &&l_0x7b, &&l_0x7c, &&l_0x7d,
        &&l_0x7e, &&l_0x7f, &&l_0x80, &&l_0x81, &&l_0x82, &&l_0x83, &&l_0x84, &&l_0x85, &&l_0x86,
        &&l_0x87, &&l_0x88, &&l_0x89, &&l_0x8a, &&l_0x8b, &&l_0x8c, &&l_0x8d, &&l_0x8e, &&l_0x8f,
        &&l_0x90, &&l_0x91, &&l_0x92, &&l_0x93, &&l_0x94, &&l_0x95, &&l_0x96, &&l_0x97, &&l_0x98,
        &&l_0x99, &&l_0x9a, &&l_0x9b, &&l_0x9c, &&l_0x9d, &&l_0x9e, &&l_0x9f, &&l_0xa0, &&l_0xa1,
        &&l_0xa2, &&l_0xa3, &&l_0xa4, &&l_0xa5, &&l_0xa6, &&l_0xa7, &&l_0xa8, &&l_0xa9, &&l_0xaa,
        &&l_0xab, &&l_0xac, &&l_0xad, &&l_0xae, &&l_0xaf, &&l_0xb0, &&l_0xb1, &&l_0xb2, &&l_0xb3,
        &&l_0xb4, &&l_0xb5, &&l_0xb6, &&l_0xb7, &&l_0xb8, &&l_0xb9, &&l_0xba, &&l_0xbb, &&l_0xbc,
        &&l_0xbd, &&l_0xbe, &&l_0xbf, &&l_0xc0, &&l_0xc1, &&l_0xc2, &&l_0xc3, &&l_0xc4, &&l_0xc5,
        &&l_0xc6, &&l_0xc7, &&l_0xc8, &&l_0xc9, &&l_0xca, &&l_0xcb, &&l_0xcc, &&l_0xcd, &&l_0xce,
        &&l_0xcf, &&l_0xd0, &&l_0xd1, &&l_0xd2, &&l_0xd3, &&l_0xd4, &&l_0xd5, &&l_0xd6, &&l_0xd7,
        &&l_0xd8, &&l_0xd9, &&l_0xda, &&l_0xdb, &&l_0xdc, &&l_0xdd, &&l_0xde, &&l_0xdf, &&l_0xe0,
        &&l_0xe1, &&l_0xe2, &&l_0xe3, &&l_0xe4, &&l_0xe5, &&l_0xe6, &&l_0xe7, &&l_0xe8, &&l_0xe9,
        &&l_0xea, &&l_0xeb, &&l_0xec, &&l_0xed, &&l_0xee, &&l_0xef, &&l_0xf0, &&l_0xf1, &&l_0xf2,
        &&l_0xf3, &&l_0xf4, &&l_0xf5, &&l_0xf6, &&l_0xf7, &&l_0xf8, &&l_0xf9, &&l_0xfa, &&l_0xfb,
        &&l_0xfc, &&l_0xfd, &&l_0xfe, &&l_0xff 
    };
    
   goto *a_jump_table[IR]; // Ah... Might as well jump... JUMP!

l_0x69:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 oldA = A;
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x65:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 oldA = A;
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x75:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 oldA = A;
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x6d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 oldA = A;
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x7d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 oldA = A;
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x79:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 oldA = A;
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x61:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 oldA = A;
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x71:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 

  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{

  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 oldA = A;
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;


l_0x4b:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  A &= operand;

  // Set carry flag according to the right-most bit
  C = A & 0x01;

  A = (A >> 1) & 0x7f;

  notZ = A;
  N = A & 0x80;
}
continue;


l_0x0b:
l_0x2b:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
  C = N;
}
continue;


l_0x29:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x25:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x35:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x2d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x3d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x39:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x21:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x31:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 

  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A &= operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x8b:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  // NOTE: The implementation of this instruction is based on
  // information from the 64doc.txt file.  This instruction is
  // reported to be unstable!
  A = (A | 0xee) & X & operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x6b:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  // NOTE: The implementation of this instruction is based on
  // information from the 64doc.txt file.  There are mixed
  // reports on its operation!
  if(!D)
  {
    A &= operand;
    A = ((A >> 1) & 0x7f) | (C ? 0x80 : 0x00);

    C = A & 0x40;
    V = (A & 0x40) ^ ((A & 0x20) << 1);

    notZ = A;
    N = A & 0x80;
  }
  else
  {
    uInt8 value = A & operand;

    A = ((value >> 1) & 0x7f) | (C ? 0x80 : 0x00);
    N = C;
    notZ = A;
    V = (value ^ A) & 0x40;

    if(((value & 0x0f) + (value & 0x01)) > 0x05)
    {
      A = (A & 0xf0) | ((A + 0x06) & 0x0f);
    }
    
    if(((value & 0xf0) + (value & 0x10)) > 0x50) 
    {
      A = (A + 0x60) & 0xff;
      C = 1;
    }
    else
    {
      C = 0;
    }
  }
}
continue;


l_0x0a:
{
}
{
  // Set carry flag according to the left-most bit in A
  C = A & 0x80;

  A <<= 1;

  notZ = A;
  N = A & 0x80;
}
continue;

l_0x06:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x16:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x0e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x1e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;


l_0x90:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(!C)
  {
    uInt16 address = PC + (Int8)operand;
    gSystemCycles++;
    if (NOTSAMEPAGE(PC, address)) gSystemCycles++;
    PC = address;
  }
}
continue;


l_0xb0:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(C)
  {
    uInt16 address = PC + (Int8)operand;
    gSystemCycles++;
    if (NOTSAMEPAGE(PC, address)) gSystemCycles++;
    PC = address;
  }
}
continue;


l_0xf0:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(!notZ)
  {
    uInt16 address = PC + (Int8)operand;
    gSystemCycles++;
    if (NOTSAMEPAGE(PC, address)) gSystemCycles++;
    PC = address;
  }
}
continue;


l_0x24:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  notZ = (A & operand);
  N = operand & 0x80;
  V = operand & 0x40;
}
continue;

l_0x2c:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  notZ = (A & operand);
  N = operand & 0x80;
  V = operand & 0x40;
}
continue;


l_0x30:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(N)
  {
    uInt16 address = PC + (Int8)operand;
    gSystemCycles++;
    if (NOTSAMEPAGE(PC, address)) gSystemCycles++;
    PC = address;
  }
}
continue;


l_0xd0:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(notZ)
  {
    uInt16 address = PC + (Int8)operand;
    gSystemCycles++;
    if (NOTSAMEPAGE(PC, address)) gSystemCycles++;
    PC = address;
  }
}
continue;


l_0x10:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(!N)
  {
    uInt16 address = PC + (Int8)operand;
    gSystemCycles++;
    if (NOTSAMEPAGE(PC, address)) gSystemCycles++;
    PC = address;
  }
}
continue;


l_0x00:
{
  peek(PC++);

  B = true;

  poke(0x0100 + SP--, PC >> 8);
  poke(0x0100 + SP--, PC & 0x00ff);
  poke(0x0100 + SP--, PS());

  I = true;

  PC = peek(0xfffe);
  PC |= ((uInt16)peek(0xffff) << 8);
}
continue;


l_0x50:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(!V)
  {
    uInt16 address = PC + (Int8)operand;
    gSystemCycles++;
    if (NOTSAMEPAGE(PC, address)) gSystemCycles++;
    PC = address;
  }
}
continue;


l_0x70:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  if(V)
  {
    uInt16 address = PC + (Int8)operand;
    gSystemCycles++;
    if (NOTSAMEPAGE(PC, address)) gSystemCycles++;
    PC = address;
  }
}
continue;


l_0x18:
{
}
{
  C = false;
}
continue;


l_0xd8:
{
}
{
  D = false;
}
continue;


l_0x58:
{
}
{
  I = false;
}
continue;


l_0xb8:
{
}
{
  V = false;
}
continue;


l_0xc9:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)A - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xc5:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)A - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xd5:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
  uInt16 value = (uInt16)A - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xcd:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)A - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xdd:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)A - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xd9:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)A - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xc1:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)A - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xd1:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 

  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)A - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;


l_0xe0:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)X - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xe4:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)X - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xec:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)X - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;


l_0xc0:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)Y - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xc4:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)Y - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;

l_0xcc:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)Y - (uInt16)operand;

  notZ = value;
  N = value & 0x0080;
  C = !(value & 0x0100);
}
continue;


l_0xcf:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  uInt16 value2 = (uInt16)A - (uInt16)value;
  notZ = value2;
  N = value2 & 0x0080;
  C = !(value2 & 0x0100);
}
continue;

l_0xdf:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  uInt16 value2 = (uInt16)A - (uInt16)value;
  notZ = value2;
  N = value2 & 0x0080;
  C = !(value2 & 0x0100);
}
continue;

l_0xdb:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  uInt16 value2 = (uInt16)A - (uInt16)value;
  notZ = value2;
  N = value2 & 0x0080;
  C = !(value2 & 0x0100);
}
continue;

l_0xc7:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  uInt16 value2 = (uInt16)A - (uInt16)value;
  notZ = value2;
  N = value2 & 0x0080;
  C = !(value2 & 0x0100);
}
continue;

l_0xd7:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  uInt16 value2 = (uInt16)A - (uInt16)value;
  notZ = value2;
  N = value2 & 0x0080;
  C = !(value2 & 0x0100);
}
continue;

l_0xc3:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  uInt16 value2 = (uInt16)A - (uInt16)value;
  notZ = value2;
  N = value2 & 0x0080;
  C = !(value2 & 0x0100);
}
continue;

l_0xd3:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  uInt16 value2 = (uInt16)A - (uInt16)value;
  notZ = value2;
  N = value2 & 0x0080;
  C = !(value2 & 0x0100);
}
continue;


l_0xc6:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  notZ = value;
  N = value & 0x80;
}
continue;

l_0xd6:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  notZ = value;
  N = value & 0x80;
}
continue;

l_0xce:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  notZ = value;
  N = value & 0x80;
}
continue;

l_0xde:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  uInt8 value = operand - 1;
  poke(operandAddress, value);

  notZ = value;
  N = value & 0x80;
}
continue;


l_0xca:
{
}
{
  X--;

  notZ = X;
  N = X & 0x80;
}
continue;


l_0x88:
{
}
{
  Y--;

  notZ = Y;
  N = Y & 0x80;
}
continue;


l_0x49:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x45:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x55:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x4d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x5d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x59:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x41:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x51:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 

  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0xe6:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt8 value = operand + 1;
  poke(operandAddress, value);

  notZ = value;
  N = value & 0x80;
}
continue;

l_0xf6:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  uInt8 value = operand + 1;
  poke(operandAddress, value);

  notZ = value;
  N = value & 0x80;
}
continue;

l_0xee:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt8 value = operand + 1;
  poke(operandAddress, value);

  notZ = value;
  N = value & 0x80;
}
continue;

l_0xfe:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  uInt8 value = operand + 1;
  poke(operandAddress, value);

  notZ = value;
  N = value & 0x80;
}
continue;


l_0xe8:
{
}
{
  X++;
  notZ = X;
  N = X & 0x80;
}
continue;


l_0xc8:
{
}
{
  Y++;
  notZ = Y;
  N = Y & 0x80;
}
continue;


l_0xef:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  operand = operand + 1;
  poke(operandAddress, operand);

  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xff:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  operand = operand + 1;
  poke(operandAddress, operand);

  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xfb:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  operand = operand + 1;
  poke(operandAddress, operand);

  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xe7:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  operand = operand + 1;
  poke(operandAddress, operand);

  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xf7:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  operand = operand + 1;
  poke(operandAddress, operand);

  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xe3:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  operand = operand + 1;
  poke(operandAddress, operand);

  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xf3:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  operand = operand + 1;
  poke(operandAddress, operand);

  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;


l_0x4c:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
}
{
  PC = operandAddress;
}
continue;

l_0x6c:
{
  uInt16 addr = peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // Simulate the error in the indirect addressing mode!
  uInt16 high = NOTSAMEPAGE(addr, addr + 1) ? (addr & 0xff00) : (addr + 1);

  operandAddress = peek(addr) | ((uInt16)peek(high) << 8);
}
{
  PC = operandAddress;
}
continue;


l_0x20:
{
  uInt8 low = peek(PC++);
  peek(0x0100 + SP);

  // It seems that the 650x does not push the address of the next instruction
  // on the stack it actually pushes the address of the next instruction
  // minus one.  This is compensated for in the RTS instruction
  poke(0x0100 + SP--, PC >> 8);
  poke(0x0100 + SP--, PC & 0xff);

  uInt16 tmp = peek(PC++);
  PC = low | (tmp << 8); 
}
continue;


l_0xbb:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A = X = SP = SP & operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0xaf:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  A = operand;
  X = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xbf:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A = operand;
  X = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xa7:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  A = operand;
  X = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xb7:
{
  operandAddress = (uInt8)(peek(PC++) + Y);
  operand = peek(operandAddress); 
}
{
  A = operand;
  X = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xa3:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  A = operand;
  X = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xb3:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 

  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A = operand;
  X = operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0xa9:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  A = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xa5:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  A = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xb5:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
  A = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xad:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  A = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xbd:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
  A = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xb9:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xa1:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  A = operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0xb1:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 

  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A = operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0xa2:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  X = operand;
  notZ = X;
  N = X & 0x80;
}
continue;

l_0xa6:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  X = operand;
  notZ = X;
  N = X & 0x80;
}
continue;

l_0xb6:
{
  operandAddress = (uInt8)(peek(PC++) + Y);
  operand = peek(operandAddress); 
}
{
  X = operand;
  notZ = X;
  N = X & 0x80;
}
continue;

l_0xae:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  X = operand;
  notZ = X;
  N = X & 0x80;
}
continue;

l_0xbe:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  X = operand;
  notZ = X;
  N = X & 0x80;
}
continue;


l_0xa0:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  Y = operand;
  notZ = Y;
  N = Y & 0x80;
}
continue;

l_0xa4:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  Y = operand;
  notZ = Y;
  N = Y & 0x80;
}
continue;

l_0xb4:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
  Y = operand;
  notZ = Y;
  N = Y & 0x80;
}
continue;

l_0xac:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  Y = operand;
  notZ = Y;
  N = Y & 0x80;
}
continue;

l_0xbc:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
  Y = operand;
  notZ = Y;
  N = Y & 0x80;
}
continue;


l_0x4a:
{
}
{
  // Set carry flag according to the right-most bit
  C = A & 0x01;

  A = (A >> 1) & 0x7f;

  notZ = A;
  N = A & 0x80;
}
continue;


l_0x46:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x56:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x4e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x5e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;


l_0xab:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  // NOTE: The implementation of this instruction is based on
  // information from the 64doc.txt file.  This instruction is
  // reported to be very unstable!
  A = X = (A | 0xee) & operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x1a:
l_0x3a:
l_0x5a:
l_0x7a:
l_0xda:
l_0xea:
l_0xfa:
{
}
{
}
continue;

l_0x80:
l_0x82:
l_0x89:
l_0xc2:
l_0xe2:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
}
continue;

l_0x04:
l_0x44:
l_0x64:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
}
continue;

l_0x14:
l_0x34:
l_0x54:
l_0x74:
l_0xd4:
l_0xf4:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
}
continue;

l_0x0c:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
}
continue;

l_0x1c:
l_0x3c:
l_0x5c:
l_0x7c:
l_0xdc:
l_0xfc:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
}
continue;


l_0x09:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x05:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x15:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x0d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x1d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x19:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x01:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x11:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 

  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x48:
{
}
{
  poke(0x0100 + SP--, A);
}
continue;


l_0x08:
{
}
{
  poke(0x0100 + SP--, PS());
}
continue;


l_0x68:
{
}
{
  peek(0x0100 + SP++);
  A = peek(0x0100 + SP);
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x28:
{
}
{
  peek(0x0100 + SP++);
  PS(peek(0x0100 + SP));
}
continue;


l_0x2f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt8 value = (operand << 1) | (C ? 1 : 0);
  poke(operandAddress, value);

  A &= value;
  C = operand & 0x80;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x3f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  uInt8 value = (operand << 1) | (C ? 1 : 0);
  poke(operandAddress, value);

  A &= value;
  C = operand & 0x80;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x3b:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt8 value = (operand << 1) | (C ? 1 : 0);
  poke(operandAddress, value);

  A &= value;
  C = operand & 0x80;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x27:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt8 value = (operand << 1) | (C ? 1 : 0);
  poke(operandAddress, value);

  A &= value;
  C = operand & 0x80;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x37:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  uInt8 value = (operand << 1) | (C ? 1 : 0);
  poke(operandAddress, value);

  A &= value;
  C = operand & 0x80;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x23:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  uInt8 value = (operand << 1) | (C ? 1 : 0);
  poke(operandAddress, value);

  A &= value;
  C = operand & 0x80;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x33:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt8 value = (operand << 1) | (C ? 1 : 0);
  poke(operandAddress, value);

  A &= value;
  C = operand & 0x80;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x2a:
{
}
{
  bool oldC = C;

  // Set carry flag according to the left-most bit
  C = A & 0x80;

  A = (A << 1) | (oldC ? 1 : 0);

  notZ = A;
  N = A & 0x80;
}
continue;


l_0x26:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  bool oldC = C;

  // Set carry flag according to the left-most bit in operand
  C = operand & 0x80;

  operand = (operand << 1) | (oldC ? 1 : 0);
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x36:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  bool oldC = C;

  // Set carry flag according to the left-most bit in operand
  C = operand & 0x80;

  operand = (operand << 1) | (oldC ? 1 : 0);
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x2e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  bool oldC = C;

  // Set carry flag according to the left-most bit in operand
  C = operand & 0x80;

  operand = (operand << 1) | (oldC ? 1 : 0);
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x3e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  bool oldC = C;

  // Set carry flag according to the left-most bit in operand
  C = operand & 0x80;

  operand = (operand << 1) | (oldC ? 1 : 0);
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;


l_0x6a:
{
}
{
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = A & 0x01;

  A = ((A >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);

  notZ = A;
  N = A & 0x80;
}
continue;

l_0x66:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x76:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x6e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;

l_0x7e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  notZ = operand;
  N = operand & 0x80;
}
continue;


l_0x6f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x7f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x7b:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x67:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x77:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x63:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0x73:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;
  bool oldC = C;

  // Set carry flag according to the right-most bit
  C = operand & 0x01;

  operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
  poke(operandAddress, operand);

  if(!D)
  {
    Int16 sum = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((sum > 127) || (sum < -128));

    sum = (Int16)A + (Int16)operand + (C ? 1 : 0);
    A = sum;
    C = (sum > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 sum = ourBCDTable[0][A] + ourBCDTable[0][operand] + (C ? 1 : 0);

    C = (sum > 99);
    A = ourBCDTable[1][sum & 0xff];
    notZ = A;
    N = A & 0x80;
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;


l_0x40:
{
}
{
  peek(0x0100 + SP++);
  PS(peek(0x0100 + SP++));
  PC = peek(0x0100 + SP++);
  PC |= ((uInt16)peek(0x0100 + SP) << 8);
}
continue;


l_0x60:
{
}
{
  peek(0x0100 + SP++);
  PC = peek(0x0100 + SP++);
  PC |= ((uInt16)peek(0x0100 + SP) << 8);
  peek(PC++);
}
continue;


l_0x8f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
}
{
  poke(operandAddress, A & X);
}
continue;

l_0x87:
{
  operandAddress = peek(PC++);
}
{
  poke(operandAddress, A & X);
}
continue;

l_0x97:
{
  operandAddress = (uInt8)(peek(PC++) + Y);
}
{
  poke(operandAddress, A & X);
}
continue;

l_0x83:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
}
{
  poke(operandAddress, A & X);
}
continue;


l_0xe9:
l_0xeb:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xe5:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xf5:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress); 
}
{
  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xed:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xfd:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + X))
  {
    gSystemCycles++;
  }

  operandAddress += X;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xf9:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;

  // See if we need to add one cycle for indexing across a page boundary
  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xe1:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;

l_0xf1:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 

  if(NOTSAMEPAGE(operandAddress, operandAddress + Y))
  {
    gSystemCycles++;
  }

  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  uInt8 oldA = A;

  if(!D)
  {
    operand = ~operand;
    Int16 difference = (Int16)((Int8)A) + (Int16)((Int8)operand) + (C ? 1 : 0);
    V = ((difference > 127) || (difference < -128));

    difference = ((Int16)A) + ((Int16)operand) + (C ? 1 : 0);
    A = difference;
    C = (difference > 0xff);
    notZ = A;
    N = A & 0x80;
  }
  else
  {
    Int16 difference = ourBCDTable[0][A] - ourBCDTable[0][operand] 
        - (C ? 0 : 1);

    if(difference < 0)
      difference += 100;

    A = ourBCDTable[1][difference];
    notZ = A;
    N = A & 0x80;

    C = (oldA >= (operand + (C ? 0 : 1)));
    V = ((oldA ^ A) & 0x80) && ((A ^ operand) & 0x80);
  }
}
continue;


l_0xcb:
{
  operandAddress = PC++;
  operand = peek(operandAddress);
}
{
  uInt16 value = (uInt16)(X & A) - (uInt16)operand;
  X = (value & 0xff);

  notZ = X;
  N = X & 0x80;
  C = !(value & 0x0100);
}
continue;


l_0x38:
{
}
{
  C = true;
}
continue;


l_0xf8:
{
}
{
  D = true;
}
continue;


l_0x78:
{
}
{
  I = true;
}
continue;


l_0x9f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y; 
}
{
  // NOTE: There are mixed reports on the actual operation
  // of this instruction!
  poke(operandAddress, A & X & (((operandAddress >> 8) & 0xff) + 1)); 
}
continue;

l_0x93:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 
  operandAddress += Y;
}
{
  // NOTE: There are mixed reports on the actual operation
  // of this instruction!
  poke(operandAddress, A & X & (((operandAddress >> 8) & 0xff) + 1)); 
}
continue;


l_0x9b:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y; 
}
{
  // NOTE: There are mixed reports on the actual operation
  // of this instruction!
  SP = A & X;
  poke(operandAddress, A & X & (((operandAddress >> 8) & 0xff) + 1)); 
}
continue;


l_0x9e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y; 
}
{
  // NOTE: There are mixed reports on the actual operation
  // of this instruction!
  poke(operandAddress, X & (((operandAddress >> 8) & 0xff) + 1)); 
}
continue;


l_0x9c:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X; 
}
{
  // NOTE: There are mixed reports on the actual operation
  // of this instruction!
  poke(operandAddress, Y & (((operandAddress >> 8) & 0xff) + 1)); 
}
continue;


l_0x0f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x1f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x1b:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x07:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x17:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x03:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x13:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the left-most bit in value
  C = operand & 0x80;

  operand <<= 1;
  poke(operandAddress, operand);

  A |= operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x4f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x5f:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x5b:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x47:
{
  operandAddress = peek(PC++);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x57:
{
  operandAddress = (uInt8)(peek(PC++) + X);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x43:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x53:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 
  operandAddress += Y;
  operand = peek(operandAddress);
}
{
  // Set carry flag according to the right-most bit in value
  C = operand & 0x01;

  operand = (operand >> 1) & 0x7f;
  poke(operandAddress, operand);

  A ^= operand;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x85:
{
  operandAddress = peek(PC++);
}
{
  poke(operandAddress, A);
}
continue;

l_0x95:
{
  operandAddress = (uInt8)(peek(PC++) + X);
}
{
  poke(operandAddress, A);
}
continue;

l_0x8d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
}
{
  poke(operandAddress, A);
}
continue;

l_0x9d:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += X; 
}
{
  poke(operandAddress, A);
}
continue;

l_0x99:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
  operandAddress += Y; 
}
{
  poke(operandAddress, A);
}
continue;

l_0x81:
{
  uInt8 pointer = peek(PC++) + X;
  operandAddress = peek(pointer) | ((uInt16)peek(pointer + 1) << 8);
}
{
  poke(operandAddress, A);
}
continue;

l_0x91:
{
  uInt8 pointer = peek(PC++);
  operandAddress = (uInt16)peek(pointer) | ((uInt16)peek(pointer + 1) << 8); 
  operandAddress += Y;
}
{
  poke(operandAddress, A);
}
continue;


l_0x86:
{
  operandAddress = peek(PC++);
}
{
  poke(operandAddress, X);
}
continue;

l_0x96:
{
  operandAddress = (uInt8)(peek(PC++) + Y);
}
{
  poke(operandAddress, X);
}
continue;

l_0x8e:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
}
{
  poke(operandAddress, X);
}
continue;


l_0x84:
{
  operandAddress = peek(PC++);
}
{
  poke(operandAddress, Y);
}
continue;

l_0x94:
{
  operandAddress = (uInt8)(peek(PC++) + X);
}
{
  poke(operandAddress, Y);
}
continue;

l_0x8c:
{
  operandAddress = (uInt16)peek(PC) | ((uInt16)peek(PC + 1) << 8);
  PC += 2;
}
{
  poke(operandAddress, Y);
}
continue;


l_0xaa:
{
}
{
  X = A;
  notZ = X;
  N = X & 0x80;
}
continue;


l_0xa8:
{
}
{
  Y = A;
  notZ = Y;
  N = Y & 0x80;
}
continue;


l_0xba:
{
}
{
  X = SP;
  notZ = X;
  N = X & 0x80;
}
continue;


l_0x8a:
{
}
{
  A = X;
  notZ = A;
  N = A & 0x80;
}
continue;


l_0x9a:
{
}
{
  SP = X;
}
continue;


l_0x98:
{
}
{
  A = Y;
  notZ = A;
  N = A & 0x80;
}
continue;

l_0x02:
l_0x12:
l_0x22:
l_0x32:
l_0x42:
l_0x52:
l_0x62:
l_0x72:
l_0x92:
l_0xb2:
l_0xd2:
l_0xf2:
  myExecutionStatus |= FatalErrorBit;
  continue;
}