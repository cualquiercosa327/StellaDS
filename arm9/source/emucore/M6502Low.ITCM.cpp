//============================================================================
//
// MM     MM  6666  555555  0000   2222
// MMMM MMMM 66  66 55     00  00 22  22
// MM MMM MM 66     55     00  00     22
// MM  M  MM 66666  55555  00  00  22222  --  "A 6502 Microprocessor Emulator"
// MM     MM 66  66     55 00  00 22
// MM     MM 66  66 55  55 00  00 22
// MM     MM  6666   5555   0000  222222
//
// Copyright (c) 1995-1998 by Bradford W. Mott
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: M6502Low.cxx,v 1.2 2002/05/13 19:10:25 stephena Exp $
//============================================================================
#include "Cart.hxx"
#include "CartAR.hxx"
#include "M6502Low.hxx"

#define debugStream cout
uInt32 NumberOfDistinctAccesses __attribute__((section(".dtcm")));

uInt8 A     __attribute__((section(".dtcm")));   // Accumulator
uInt8 X     __attribute__((section(".dtcm")));   // X index register
uInt8 Y     __attribute__((section(".dtcm")));   // Y index register
uInt8 SP    __attribute__((section(".dtcm")));   // Stack Pointer
uInt16 PC   __attribute__((section(".dtcm")));   // Program Counter

uInt8 N     __attribute__((section(".dtcm")));   // N flag for processor status register
uInt8 V     __attribute__((section(".dtcm")));   // V flag for processor status register
uInt8 B     __attribute__((section(".dtcm")));   // B flag for processor status register
uInt8 D     __attribute__((section(".dtcm")));   // D flag for processor status register
uInt8 I     __attribute__((section(".dtcm")));   // I flag for processor status register
uInt8 notZ  __attribute__((section(".dtcm")));   // Z flag complement for processor status register
uInt8 C     __attribute__((section(".dtcm")));   // C flag for processor status register

extern CartridgeAR *myAR;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502Low::M6502Low(uInt32 systemCyclesPerProcessorCycle)
    : M6502(systemCyclesPerProcessorCycle)
{
    NumberOfDistinctAccesses = 0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
M6502Low::~M6502Low()
{
}


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void M6502Low::fake_peek()
{
  gSystemCycles++;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline uInt8 M6502Low::peek_distinct(uInt16 address)
{
  NumberOfDistinctAccesses++;
  gSystemCycles++;
  if (address & 0xF000) return myAR->peek(address);
  return mySystem->peek(address);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void M6502Low::poke_distinct(uInt16 address, uInt8 value)
{
  NumberOfDistinctAccesses++;
  gSystemCycles++;  
  mySystem->poke(address, value);
}


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline uInt8 M6502Low::peek(uInt16 address)
{
  gSystemCycles++;
  return mySystem->peek(address);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
inline void M6502Low::poke(uInt16 address, uInt8 value)
{
  gSystemCycles++;  
  mySystem->poke(address, value);
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

bool M6502Low::execute(uInt16 number)
{
  uInt8  IR;
  uInt16 fast_loop = number;
    
  // ----------------------------------------------------------------
  // For Starpath Supercharger games, we must track distinct memory
  // access. This takes time so we don't do it for other game types...
  // ----------------------------------------------------------------
  if (myCartInfo.special == SPEC_DISTADDR)
  {
    return execute_distinct(number);   
  }
      
  // Clear all of the execution status bits except for the fatal error bit
  myExecutionStatus &= FatalErrorBit;

  // Loop until execution is stopped or a fatal error occurs
  for(;;)
  {
    for(; !myExecutionStatus && (fast_loop != 0); --fast_loop)
    {
      uInt16 operandAddress=0;
      uInt8 operand=0;
        
      // Get the next 6502 instruction
      IR = peek(PC++);

      // 6502 instruction emulation is generated by an M4 macro file
      switch (IR)
      {
        #include "M6502Low.ins"        
      }
    }

    // See if we need to handle an interrupt
    if(myExecutionStatus & (MaskableInterruptBit | NonmaskableInterruptBit))
    {
      // Yes, so handle the interrupt
      interruptHandler();
    }

    // See if execution has been stopped
    if(myExecutionStatus & StopExecutionBit)
    {
      // Yes, so answer that everything finished fine
      return true;
    }

    // See if a fatal error has occured
    if(myExecutionStatus & FatalErrorBit)
    {
      // Yes, so answer that something when wrong
      return false;
    }

    // See if we've executed the specified number of instructions
    if(fast_loop == 0)
    {
      // Yes, so answer that everything finished fine
      return true;
    }
  }
}


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void M6502Low::interruptHandler()
{
  // Handle the interrupt
  if((myExecutionStatus & MaskableInterruptBit) && !I)
  {
    gSystemCycles += 7; // 7 cycle operation
    mySystem->poke(0x0100 + SP--, (PC - 1) >> 8);		// The high byte of the return address
    mySystem->poke(0x0100 + SP--, (PC - 1) & 0x00ff);	// The low byte of the return address
    mySystem->poke(0x0100 + SP--, PS() & (~0x10));	// The status byte from the processor status register
    D = false;	// Set our flags
    I = true;
    PC = (uInt16)mySystem->peek(0xFFFE) | ((uInt16)mySystem->peek(0xFFFF) << 8);	// Grab the address from the interrupt vector
  }
  else if(myExecutionStatus & NonmaskableInterruptBit)
  {
    gSystemCycles += 7; // 7 cycle operation
    mySystem->poke(0x0100 + SP--, (PC - 1) >> 8);
    mySystem->poke(0x0100 + SP--, (PC - 1) & 0x00ff);
    mySystem->poke(0x0100 + SP--, PS() & (~0x10));
    D = false;
    PC = (uInt16)mySystem->peek(0xFFFA) | ((uInt16)mySystem->peek(0xFFFB) << 8);
  }

  // Clear the interrupt bits in myExecutionStatus
  myExecutionStatus &= ~(MaskableInterruptBit | NonmaskableInterruptBit);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const char* M6502Low::name() const
{
  return "M6502Low";
}

bool M6502Low::execute_distinct(uInt16 number)
{
  uInt8  IR;
  uInt16 fast_loop = number;
    
  // Clear all of the execution status bits except for the fatal error bit
  myExecutionStatus &= FatalErrorBit;

  // Loop until execution is stopped or a fatal error occurs
  for(;;)
  {
    for(; !myExecutionStatus && (fast_loop != 0); --fast_loop)
    {
      uInt16 operandAddress=0;
      uInt8 operand=0;
        
      // Get the next 6502 instruction
      // This is not clean - but is faster...
      IR = peek_distinct(PC++);

      // 6502 instruction emulation is generated by an M4 macro file
      switch (IR)
      {
        // A trick of the light... here we map peek/poke to the distinct versions. Slower but needed for some games...
        #define peek peek_distinct
        #define poke poke_distinct
        #include "M6502Low.ins"        
      }
    }

    // See if we need to handle an interrupt
    if(myExecutionStatus & (MaskableInterruptBit | NonmaskableInterruptBit))
    {
      // Yes, so handle the interrupt
      interruptHandler();
    }

    // See if execution has been stopped
    if(myExecutionStatus & StopExecutionBit)
    {
      // Yes, so answer that everything finished fine
      return true;
    }

    // See if a fatal error has occured
    if(myExecutionStatus & FatalErrorBit)
    {
      // Yes, so answer that something when wrong
      return false;
    }

    // See if we've executed the specified number of instructions
    if(fast_loop == 0)
    {
      // Yes, so answer that everything finished fine
      return true;
    }
  }
}
